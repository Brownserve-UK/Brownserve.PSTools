<#
.SYNOPSIS
    Creates a new editorconfig configuration.
.DESCRIPTION
    This cmdlet will create a new editorconfig configuration without writing it to disk.
#>
function New-BrownserveEditorConfig
{
    [CmdletBinding()]
    param
    (
        # Whether or not to include the root editorconfig file
        [Parameter(
            Mandatory = $false,
            ValueFromPipeline = $false,
            ValueFromPipelineByPropertyName = $true,
            Position = 0
        )]
        [bool]
        $IncludeRoot = $true,

        # The section to add to the editorconfig file
        [Parameter(
            Mandatory = $true,
            ValueFromPipeline = $true,
            ValueFromPipelineByPropertyName = $true,
            Position = 1
        )]
        [EditorConfigSection[]]
        $Section,

        # Any manual changes to the editorconfig file
        [Parameter(
            Mandatory = $false,
            ValueFromPipeline = $false,
            ValueFromPipelineByPropertyName = $true,
            Position = 2
        )]
        [string[]]
        $ManualSection
    )
    begin
    {
        $Header = @"
# EditorConfig Helps Developers Define and Maintain Consistent Coding Styles Between Different Editors and IDEs.
# For more information about the file format, see http://EditorConfig.org.

# WARNING: THIS FILE IS MANAGED BY A TOOL, MANUAL CHANGES MAY BE LOST UNLESS IN THE DEDICATED SECTION BELOW`

# AUTOGENERATED EDITORCONFIG STARTS HERE`n`n
"@
    }
    process
    {
        $Return = $Header
        if ($IncludeRoot -eq $true)
        {
            $Return += @"
# top-most EditorConfig file
root = true`n`n
"@
        }
        $Section | ForEach-Object {
            $Return += $_.ToString()
            if ($_ -ne $Section[-1])
            {
                $Return += "`n"
            }
        }

        $Return += "`n# MANUAL CHANGES BELOW THIS LINE WILL BE PRESERVED"
        if ($null -ne $ManualSection)
        {
            $ManualSection | ForEach-Object {
                $Return += $_
                if ($_ -ne $ManualSection[-1])
                {
                    $Return += "`n"
                }
            }
        }
        else
        {
            # Try to stop reading/writing the same newline character over and over again ðŸ˜‡
            $Return += "`n"
        }
    }
    end
    {
        if ($Return -ne $Header)
        {
            $Return = $Return | Format-BrownserveContent
            Return $Return
        }
        else
        {
            return $null
        }
    }
}
